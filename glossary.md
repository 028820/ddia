# 术语表 【DRAFT】

> 请注意，本术语表中的定义简短而简单，旨在传达核心思想，而不是术语的完整细微之处。 有关更多详细信息，请参阅正文中的参考资料。



[TOC]



### 异步（asynchronous）

不等待某些事情完成（例如，通过网络将数据发送到另一个节点），并且不会假设要花多长时间。请参阅第153页上的“同步与异步复制”，第284页上的“同步与异步网络”，以及第306页上的“系统模型与现实”。



### 原子（atomic）

1.在并发操作的上下文中：描述一个在单个时间点看起来生效的操作，所以另一个并发进程永远不会遇到处于“半完成”状态的操作。另见隔离。

2.在事务的上下文中：即使出现故障，将一组必须全部提交或全部回滚的写入组合在一起。参见第223页的“原子性”和第354页的“原子提交和两阶段提交（2PC）”。



### 背压（backpressure）

强制一些数据的发送者减慢，因为收件人不能保留
与它一起。也称为流量控制。请参阅第441页上的“消息系统”。



### 批处理（batch process）

一种计算，它将一些固定的（通常是大的）数据集作为输入，并将其他一些数据作为输出，而不修改输入。见第十章。



### 边界（bounded）

有一些已知的上限或大小。例如，在网络延迟的情况下（请参阅“超时和未定义的延迟”在本页281）和数据集（请参阅第11章的介绍）。



### 拜占庭故障（Byzantine fault）

以任意方式表现不正确的节点，例如通过向其他节点发送矛盾或恶意消息。请参阅第304页上的“拜占庭故障”。



### 缓存（cache）

最近记住使用数据的组件，以加快未来对相同数据的读取速度。它通常是不完整的：因此，如果缓存中缺少某些数据，则必须从某些底层较慢的数据存储系统具有完整的数据副本。



### CAP定理（CAP theorem）

一个被广泛误解的理论结果，在实践中是没有用的。参见第336页的“CAP定理”。



### 因果关系（causality）

事件之间的依赖关系，当一件事发生在另一件事情之前。例如，后面的事件是对早期事件的回应，或者建立在更早的事件上，或者应该根据先前的事件来理解。请参阅第186页上的“发生之前的关系和并发性”和第339页上的“排序和因果关系”。



### 共识（consensus）

分布式计算的一个基本问题，就是让几个节点同意某些事情（例如，哪个节点应该是数据库集群的领导者）。问题比乍看起来要困难得多。请参阅第364页上的“容错共识”。



### 数据仓库（data warehouse）

一个数据库，其中来自几个不同的OLTP系统的数据已经被合并和准备用于分析目的。请参阅第91页上的“数据仓库”。



### 声明式（declarative）

描述某些东西应该具有的属性，但不知道如何实现它的确切步骤。在查询的上下文中，查询优化器采用声明性查询并决定如何最好地执行它。请参阅第42页上的“数据的查询语言”。



### 非规范化（denormalize）

为了加速读取，在标准数据集中引入一些冗余或重复数据，通常采用缓存或索引的形式。非规范化的值是一种预先计算的查询结果，视图。请参见“单对象和多对象操作”（第228页）和“从同一事件日志中派生多个视图”（第461页）。



### 派生数据（derived data）

通过可重复的流程从其他数据创建的数据集，如有必要，您可以再次运行该数据集。通常，需要派生数据来加速对数据的特定读访问。索引，缓存和物化视图是派生数据的示例。参见第三部分的介绍。



### 确定性（deterministic）

描述一个函数，如果给它相同的输入，则总是产生相同的输出。这意味着它不能依赖于随机数字，时间，网络通信或其他不可预测的事情。



### 分布式（distributed）

在由网络连接的多个节点上运行。以部分故障为特征：系统的某些部分可能被破坏，而其他部分仍在工作，软件通常不可能知道究竟是什么被破坏。请参阅第274页上的“故障和部分故障”。



### 持久（durable）

以某种方式存储数据，即使发生各种故障，也不会丢失数据。请参阅第226页上的“耐用性”。



### ETL（Extract-Transform-Load）

提取-转换-加载（Extract-Transform-Load）。从源数据库中提取数据，将其转换为更适合分析查询的形式，并将其加载到数据仓库或批处理系统中的过程。请参阅第91页上的“数据仓库”。



### 故障转移（failover）

在具有单一领导者的系统中，故障转移是将领导角色从一个节点转移到另一个节点的过程。请参阅第156页的“处理节点中断”。



### 容错（fault-tolerant）

如果出现问题（例如，机器崩溃或网络连接失败），可以自动恢复。请参阅第6页上的“可靠性”。



### 流量控制（flow control）

见背压（backpressure）。



### 追随者（follower）

不直接接受来自客户端的任何写入的副本，但仅处理从领导者收到的数据更改。也称为辅助，从，只读副本或热备份。请参阅第152页上的“领导和追随者”。



### 全文检索（full-text search）

通过任意关键字来搜索文本，通常具有附加特征，例如匹配类似的拼写词或同义词。全文索引是一种支持这种查询的次级索引。请参见第88页上的“全文搜索和模糊索引”。



### 图（graph）

由顶点组成的数据结构（可以引用的东西，也称为节点或实体）和边（从一个顶点到另一个顶点的连接，也称为关系或弧）。请参阅第49页上的“类似图形的数据模型”。 



### 散列（hash）

汇集有共同点的记录。在一个记录与另一个记录有关（外键，文档参考，图中的边）的情况下最常用，查询需要获

取参考所指向的记录。请参阅第33页上的“多对一和多对多关系”和第393页上的“减少端连接和分组”。



### 幂等（idempotent）

### 索引（index）

### 隔离（isolation）

### 连接（join）

### 领导者（leader）

当数据或服务被复制到多个节点时，领导是被允许进行更改的指定副本。领导者可以通过某些协议选举产生，也可以由管理者手动选择。也被称为主或主。见“领导和F

### 线性化（linearizable）

### 局部性（locality）

### 锁（lock）

### 日志（log）

### 物化（materialize）

### 节点（node）

### 规范化（normalized）

### OLAP（Online Analytic Processing）

### OLTP（Online Transaction Processing）

### 分区（partitioning）

### 百分位点（percentile）

### 主键（primary key）

### 法定人数（quorum）

### 再平衡（rebalance）

### 复制（replication）

### 模式（schema）

### 次级索引（secondary index）

### 可序列化（serializable）

### 无共享（shared-nothing）

### 偏差（skew）

### 脑裂（split brain）

### 存储过程（stored procdure）

### 流处理（stream process）

### 同步（synchronous）

### 记录系统（system of record）

### 超时（timeout）

### 全序（total order）

### 事务（transaction）

### 两阶段提交（2PC, two-phase commit）

### 两阶段锁定（2PL, two-phase locking）

### 无限制（unbounded）
